%{
#include "phase2.tab.h" // This will be generated by Bison and contains token definitions
#include <string.h>
%}

%option noyywrap
%option yylineno 

%%

"if"            { return IF; }
"else"          { return ELSE; }
"while"         { return WHILE; }
"for"           { return FOR; }
"return"        { return RETURN; }
"struct"        { return KEYWORD; } // Keeping KEYWORD for simplicity for other types

"auto"          { return KEYWORD; }
"break"         { return KEYWORD; }
"case"          { return KEYWORD; }
"char"          { return KEYWORD; }
"const"         { return KEYWORD; }
"continue"      { return KEYWORD; }
"void"          { return KEYWORD; } // Changed to KEYWORD, if we want specific type, we define token for it
"default"       { return KEYWORD; }
"do"            { return KEYWORD; }
"double"        { return KEYWORD; }
"enum"          { return KEYWORD; }
"extern"        { return KEYWORD; }
"float"         { return KEYWORD; }
"goto"          { return KEYWORD; }
"int"           { return KEYWORD; } // Changed to KEYWORD. If we need specific 'int' token for func type, define it.
"long"          { return KEYWORD; }
"register"      { return KEYWORD; }
"short"         { return KEYWORD; }
"signed"        { return KEYWORD; }
"sizeof"        { return KEYWORD; }
"static"        { return KEYWORD; }
"switch"        { return KEYWORD; }
"typedef"       { return KEYWORD; }
"union"         { return KEYWORD; }
"unsigned"      { return KEYWORD; }
"volatile"      { return KEYWORD; }

"=="            { return EQ; }
"!="            { return NEQ; }
"<="            { return LE; }
">="            { return GE; }
"<"             { return LT; }
">"             { return GT; }

"+"             { return PLUS; }
"-"             { return MINUS; }
"*"             { return MUL; }
"/"             { return DIV; }
"="             { return ASSIGN; }

";"             { return SEMICOLON; }
","             { return COMMA; }
"("             { return LPAREN; }
")"             { return RPAREN; }
"{"             { return LBRACE; }
"}"             { return RBRACE; }
"["             { return LBRACKET; }
"]"             { return RBRACKET; }

[0-9]+          {
    yylval.str = strdup(yytext);
    return NUM;
}

[a-zA-Z_][a-zA-Z0-9_]* {
    yylval.str = strdup(yytext);
    return ID;
}

[ \t\n]+        ; /* Ignore whitespace */
.               {
    fprintf(stderr, "Lexical error: Unexpected character '%s' at line %d\n", yytext, yylineno);
    return yytext[0]; // Return the character itself for a generic error
}

%%